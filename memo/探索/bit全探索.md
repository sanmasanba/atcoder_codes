# 実装
```Python
res = 0
for i in range(2**N):
    #ここで判定用の変数を初期化する
    #ex) total = 0
    for j in range(N):
        if (i >> j) & 1:
            #ここで何か操作を入れる
            #total += list[j]
    #組み合わせに関して、要素を満たすか判定する
    #ex) if total == target:
    #       res += 1 

```
# 使える場面
- N個のものから、いくつかを選ぶときを全列挙して調べ上げる

# bit全探索の考え方
N=3個のものがあって、それぞれの組み合わせについて考える。その組み合わせはの関係は$2^3$通りあると考えられる。\
この問題は、n番目のものを選ぶか選ばないかという問題と考えられるので、以下の表のように対応づけられる。(　_ は使用していない文字を表す)

組み合わせ|bit表記|10進数
-:|-:|-:
___|000|0
__a|001|1
\_b\_|010|2
_ba|011|3
c__|100|4
c_a|101|5
cb_|110|6
cba|111|7

つまり、$2^N$通りの組み合わせに対して、0, 1, 2, 3, ... , $2^N-1$という整数値を対応させることができる。\
実装のこの部分は、組み合わせの全列挙(上の表のそれぞれの10進数に対応)をしている。
```Python
for i in range(N):
```
次に、実際にbitシフトをさせる
```Python
for j in range(N):
    if (i >> j) & 1:
```
for文はbit列の0文字目からN－1文字目までに対応していて、中のif文はj番目の要素を選んだかを調べている。
```
i = 3
bit(i) = 011
(3 >> 0) & 1 = 1    #(3 >> 0) = 011
(3 >> 1) & 1 = 1    #(3 >> 1) = 001
(3 >> 2) & 1 = 0    #(3 >> 2) = 000
```
上の例のように、右bitシフトによってj番目のbitが立っているかを確認して、条件を満たすときに操作を行うことですべてのパターンを試すことができる。

