{
	// テンプレ
	"python_template": {
		"prefix": "calltemplate",
		"body": [
			"#library",
			"import sys, re",
			"from math import ceil, floor, sqrt, pi, gcd, lcm, factorial",
			"from operator import mul",
			"from heapq import heappush, heappop",
			"from collections import deque, Counter, defaultdict",
			"from bisect import bisect, bisect_left, bisect_right",
			"from functools import lru_cache, cmp_to_key, reduce",
			"from itertools import permutations, combinations, accumulate",
			"from typing import Generic, Iterable, Iterator, \\",
				"\tList, Tuple, Dict, TypeVar, Optional, Any, Callable",
			"T = TypeVar('T')",
			"",
			"sys.setrecursionlimit(10**6)",
			"INF = float('inf')",
			"",
			"#main",
			"def main():",
				"\t# intput",
				"\t$1",
			"",
			"if __name__ == '__main__':",
			"\tmain()"
		],
	},

	// 入力
	"複数回の(A, B)を別々に保存": {
		"prefix": "inputAB",
		"body": [
			"A, B = map(list, zip(*[list(map(int, input().split(' '))) for _ in range(N)]))",
			"$1"
		]
	},
	"１入力": {
		"prefix": "inputN",
		"body": [
			"N = int(input())",
			"$1"
		]
	},
	"２入力": {
		"prefix": "inputNM",
		"body": [
			"N, M = map(int, input().split(' '))",
			"$1"
		]
	},
	"複数回の１入力": {
		"prefix": "inputL",
		"body": [
			"L = [int(input()) for _ in range(N)]",
			"$1"
		]
	},
	"複数回のN入力": {
		"prefix": "inputQ",
		"body": [
			"Q = [list(map(int, input().split(' '))) for _ in range(N)]",
			"$1"
		]
	},
	"[A_1, A_2, A_3, ...]": {
		"prefix": "inputA",
		"body": [
			"A = list(map(int, input().split(' ')))",
			"$1"
		]
	},
	"['a', 't', 'c', ...]": {
		"prefix": "inputS",
		"body": [
			"S = list(input())",
			"$1"
		]
	},
	"simple_graph": {
		"prefix": "input_simpleG",
		"body": [
			"N, M = map(int, input().split(' '))",
			"G = [[] for _ in range(N)]",
			"for _ in range(M):",
				"\ta, b = map(int, input().split(' '))",
				"\tG[a].append(b)",
				"\t# 有向グラフは次の列を削除",
				"\tG[b].append(a)",
			"$1"
		]
	},
	"weighted_graph": {
		"prefix": "input_weightedG",
		"body": [
			"N, M = map(int, input().split(' '))",
			"G = defaultdict(list)",
			"for _ in range(M):",
				"\ts, g, weight = map(int, input().split(' '))",
				"\tG[s].append((g, weight))",
				"\t# 有向グラフは下の列を削除",
				"\tG[g].append((s, weight))",
			"$1"
		]
	},

	// 出力
	"Yes or No": {
		"prefix": "output_Yes_No",
		"body": [
			"print('Yes' if res else 'No')",
			"$1"
		]
	},

	// 整数・素数
	"素因数の列挙": {
		"prefix": "prime_factorization",
		"body": [
			"#prime_factorization",
			"def prime_factorization(N) -> list:",
		    "\tres = []",
		    "\tfor p in range(2, N):",
    	    	"\t\tif p * p > N:",
        		    "\t\t\tbreak",
        		"\t\tif N % p != 0:",
            		"\t\t\tcontinue",
        		"\t\te = 0",
	        	"\t\twhile N % p == 0:",
            		"\t\t\te += 1",
            		"\t\t\tN //= p",
        		"\t\tres.append((p, e))",
    		"\tif N != 1:",
		        "\t\tres.append((N, 1))",
    		"\treturn res"
		],
	},
	"素因数の判定": {
		"prefix": "prime_test",
		"body": [
			"#prime_test",
			"def prime_test(N):",
		    "\tres = 'Yes'",
		    "\tfor p in range(2, N):",
    	    	"\t\tif p * p > N:",
        		    "\t\t\tbreak",
        		"\t\tif N % p != 0:",
            		"\t\t\tcontinue",
	        	"\t\tif N % p == 0:",
            		"\t\t\tres = 'No'",
            		"\t\t\tbreak",
    		"\treturn res"
		],
	},
	"フェルマーの小定理を使った逆元": {
		"prefix": "modinv",
		"body": [
			"def mod_inverse(a, p):",
				"\treturn pow(a, p-2, p)"
		]
	},
	"エラトステネスの篩": {
		"prefix": "eratosthenes",
		"body": [
			"# eratosthenes",
			"def eratosthenes(N: int) -> List[int]:",
				"\tisprime = [True] * (N+1)",
				"",
				"\tisprime[0], isprime[1] = False, False",
				"",
				"\tfor p in range(2, N+1):",
					"\t\tif not isprime[p]:",
						"\t\t\tcontinue",
					"",
					"\t\tq = p * 2",
					"\t\twhile q <= N:",
						"\t\t\tisprime[q] = False",
						"\t\t\tq += p",
				"",
				"\treturn [i for i, e in enumerate(isprime) if e]",
		]
	},

	// 公式
	"ユークリッド距離": {
		"prefix": "calc_Euclid",
		"body": [
			"def euclidean_distance(x1: T, x2: T, y1: T, y2: T) -> T:",
				"\treturn sqrt((x2-x1)**2 + (y2-y1)**2)"
		]
	},
	"マンハッタン距離": {
		"prefix": "calc_Manhattan",
		"body": [
			"def manhattan_distance(x1: T, x2: T, y1: T, y2: T) -> T:",
				"\treturn abs(x2-x1) + abs(y2-y1)"
		]
	},
	"組み合わせの総数": {
		"prefix": "calc_nCr",
		"body": [
			"def nums_of_combination(n: int, r: int) -> int:",
				"\tif r == 0:",
					"\t\treturn 1",
				"\tover = reduce(mul, range(n, n-r, -1))",
				"\tunder = reduce(mul, range(1, r+1))",
				"\treturn over // under",
		]
	},
	"順列の総数": {
		"prefix": "calc_nPr",
		"body": [
			"def nums_of_permutation(n: int, r: int) -> int:",
				"\tif r == 0:",
					"\t\treturn 1",
				"\tover = reduce(mul, range(1, n+1))",
				"\tunder = reduce(mul, range(1, n-r+1))",
				"\treturn over // under",
		]
	},
	"等差数列の和": {
		"prefix": "calc_sum_arithmetic",
		"body": [
			"def sum_of_arithmetic(begin: int, end: int, num: int) -> int:",
				"\treturn (begin + end) // 2 * num",
		]
	},
	"等比数列の和": {
		"prefix": "calc_sum_geometric",
		"body": [
			"def sum_of_geometric(a: int, r: int, n: int) -> int:",
				"\tover = a * (pow(r, n) - 1)",
				"\tunder = r - 1",
				"\treturn over // under",
		]
	},

	// 累積和
	"一次元累積和": {
		"prefix": "cumsum",
		"body": [
			"cumsum = [0] + list(accumulate(A))",
		]
	},
	"二次元累積和": {
		"prefix": "cumsum2d",
		"body": [
			"def cumsum2d(n:int, a:List[T]) -> List[T]:",
				"\ttmp = [[0] * (n+1) for _ in range(n+1)]",
				"\tfor i in range(n):",
					"\t\tfor j in range(n):",
						"\t\t\ttmp[i+1][j+1] = (",
							"\t\t\t\ttmp[i+1][j]",
							"\t\t\t\t+ tmp[i][j+1]",
							"\t\t\t\t- tmp[i][j]",
							"\t\t\t\t+ a[i][j]",
							"\t\t\t\t)",
				"\treturn tmp",
		]
	},
	"三次元累積和": {
		"prefix": "cumsum3d",
		"body": [
			"def cumsum3d(n:int, a:list) -> List[T]:",
				"\ttmp = [[[0] * (n + 1) for _ in range(n + 1)] for _ in range(n + 1)]",
				"\tfor i in range(n):",
					"\t\tfor j in range(n):",
						"\t\t\tfor k in range(n):",
							"\t\t\t\ttmp[i + 1][j + 1][k + 1] = (",
								"\t\t\t\t\ttmp[i][j+1][k+1]",
								"\t\t\t\t\t+ tmp[i+1][j][k+1]",
								"\t\t\t\t\t+ tmp[i+1][j+1][k]",
								"\t\t\t\t\t- tmp[i][j][k+1]",
								"\t\t\t\t\t- tmp[i][j+1][k]",
								"\t\t\t\t\t- tmp[i+1][j][k]",
								"\t\t\t\t\t+ tmp[i][j][k]",
								"\t\t\t\t\t+ a[i][j][k]",
								"\t\t\t\t)",
				"\treturn tmp"
		]
	},

	// データ構造
	"Union Find": {
		"prefix": "unionfind",
		"body": [
			"class UnionFind():",
				"\t###",
				"\t#",
				"\t# UnionFindの実装",
				"\t# https://note.nkmk.me/python-union-find/",
				"\t#",
				"\t###",
				"\tdef __init__(self, n: int) -> None:",
					"\t\tself.n = n",
					"\t\tself.parents = [-1] * n",
				"\t# 要素xが属するグループの根を返す",
				"\tdef find(self, x: int) -> int:",
					"\t\tif self.parents[x] < 0:",
						"\t\t\treturn x",
					"\t\telse:",
						"\t\t\tself.parents[x] = self.find(self.parents[x])",
						"\t\t\treturn self.parents[x]",
				"\t# 要素xが属するグループと要素yが属するグループを併合する",
				"\tdef union(self, x: int, y: int) -> None:",
					"\t\tx = self.find(x)",
					"\t\ty = self.find(y)",
					"\t\tif x == y:",
						"\t\t\treturn ",
					"\t\tif self.parents[x] > self.parents[y]:",
						"\t\t\tx, y = y, x",
					"\t\tself.parents[x] += self.parents[y]",
					"\t\tself.parents[y] = x",
				"\t# 要素xが属するグループのサイズを返す",
				"\tdef size(self, x: int) -> int:",
					"\t\treturn -self.parents[self.find(x)]",
				"\t# 要素xと要素yが同じグループに属するかを返す",
				"\tdef same(self, x: int, y: int) -> bool:",
					"\t\treturn self.find(x) == self.find(y)",
				"\t# 要素xが属するグループに属する要素をリストで返す",
				"\tdef members(self, x: int) -> List[int]:",
					"\t\troot = self.find(x)",
					"\t\treturn [i for i in range(self.n) if self.find(i) == root]",
				"\t# 根のリストを返す",
				"\tdef roots(self) -> List[int]:",
					"\t\treturn [i for i, x in enumerate(self.parents) if x < 0]",
				"\t# グループの数を返す",
				"\tdef group_count(self) -> int:",
					"\t\treturn len(self.roots())",
				"\t# {根:[そのグループに含まれる要素のリスト], ...}のdefaultdictを返す",
				"\tdef all_group_members(self) -> Dict[int, List[int]]:",
					"\t\tgroup_members = defaultdict(list)",
					"\t\tfor member in range(self.n):",
						"\t\t\tgroup_members[self.find(member)].append(member)",
					"\t\treturn group_members",
				"\tdef __str__(self) -> str:",
					"\t\treturn '\\n'.join(f'{r}: {m}' for r, m in self.all_group_members().items())"
		]
	},
	"Sortedset": {
		"prefix": "SortedSet",
		"body": [
			"import math",
			"",
			"class SortedSet(Generic[T]):",
			"\t#",
			"\t# https://github.com/tatyam-prime/SortedSet/blob/main/SortedSet.py",
			"\t#",
			"\tBUCKET_RATIO = 16",
			"\tSPLIT_RATIO = 24",
			"\t",
			"\tdef __init__(self, a: Iterable[T] = []) -> None:",
			"\t\t# Make a new SortedSet from iterable. / O(N) if sorted and unique / O(N log N)",
			"\t\ta = list(a)",
			"\t\tn = len(a)",
			"\t\tif any(a[i] > a[i + 1] for i in range(n - 1)):",
			"\t\t\ta.sort()",
			"\t\tif any(a[i] >= a[i + 1] for i in range(n - 1)):",
			"\t\t\ta, b = [], a",
			"\t\t\tfor x in b:",
			"\t\t\t\tif not a or a[-1] != x:",
			"\t\t\t\t\ta.append(x)",
			"\t\tn = self.size = len(a)",
			"\t\tnum_bucket = int(math.ceil(math.sqrt(n / self.BUCKET_RATIO)))",
			"\t\tself.a = [a[n * i // num_bucket : n * (i + 1) // num_bucket] for i in range(num_bucket)]",
			"",
			"\tdef __iter__(self) -> Iterator[T]:",
			"\t\tfor i in self.a:",
			"\t\t\tfor j in i: yield j",
			"",
			"\tdef __reversed__(self) -> Iterator[T]:",
			"\t\tfor i in reversed(self.a):",
			"\t\t\tfor j in reversed(i): yield j",
			"\t",
			"\tdef __eq__(self, other) -> bool:",
			"\t\treturn list(self) == list(other)",
			"\t",
			"\tdef __len__(self) -> int:",
			"\t\treturn self.size",
			"\t",
			"\tdef __repr__(self) -> str:",
			"\t\treturn 'SortedSet' + str(self.a)",
			"\t",
			"\tdef __str__(self) -> str:",
			"\t\ts = str(list(self))",
			"\t\treturn '{' + s[1 : len(s) - 1] + '}'",
			"",
			"\tdef _position(self, x: T) -> Tuple[List[T], int, int]:",
			"\t\t# return the bucket, index of the bucket and position in which x should be. self must not be empty.",
			"\t\tfor i, a in enumerate(self.a):",
			"\t\t\tif x <= a[-1]: break",
			"\t\treturn (a, i, bisect_left(a, x))",
			"",
			"\tdef __contains__(self, x: T) -> bool:",
			"\t\tif self.size == 0: return False",
			"\t\ta, _, i = self._position(x)",
			"\t\treturn i != len(a) and a[i] == x",
			"",
			"\tdef add(self, x: T) -> bool:",
			"\t\t# Add an element and return True if added. / O(√N)",
			"\t\tif self.size == 0:",
			"\t\t\tself.a = [[x]]",
			"\t\t\tself.size = 1",
			"\t\t\treturn True",
			"\t\ta, b, i = self._position(x)",
			"\t\tif i != len(a) and a[i] == x: return False",
			"\t\ta.insert(i, x)",
			"\t\tself.size += 1",
			"\t\tif len(a) > len(self.a) * self.SPLIT_RATIO:",
			"\t\t\tmid = len(a) >> 1",
			"\t\t\tself.a[b:b+1] = [a[:mid], a[mid:]]",
			"\t\treturn True",
			"\t",
			"\tdef _pop(self, a: List[T], b: int, i: int) -> T:",
			"\t\tans = a.pop(i)",
			"\t\tself.size -= 1",
			"\t\tif not a: del self.a[b]",
			"\t\treturn ans",
			"",
			"\tdef discard(self, x: T) -> bool:",
			"\t\t# Remove an element and return True if removed. / O(√N)",
			"\t\tif self.size == 0: return False",
			"\t\ta, b, i = self._position(x)",
			"\t\tif i == len(a) or a[i] != x: return False",
			"\t\tself._pop(a, b, i)",
			"\t\treturn True",
			"\t",
			"\tdef lt(self, x: T) -> Optional[T]:",
			"\t\t# Find the largest element < x, or None if it doesn't exist.",
			"\t\tfor a in reversed(self.a):",
			"\t\t\tif a[0] < x:",
			"\t\t\t\treturn a[bisect_left(a, x) - 1]",

			"\tdef le(self, x: T) -> Optional[T]:",
			"\t\t# Find the largest element <= x, or None if it doesn't exist.",
			"\t\tfor a in reversed(self.a):",
			"\t\t\tif a[0] <= x:",
			"\t\t\t\treturn a[bisect_right(a, x) - 1]",
			"",
			"\tdef gt(self, x: T) -> Optional[T]:",
			"\t\t# Find the smallest element > x, or None if it doesn't exist.",
			"\t\tfor a in self.a:",
			"\t\t\tif a[-1] > x:",
			"\t\t\t\treturn a[bisect_right(a, x)]",
			"",
			"\tdef ge(self, x: T) -> Optional[T]:",
			"\t\t# Find the smallest element >= x, or None if it doesn't exist.",
			"\t\tfor a in self.a:",
			"\t\t\tif a[-1] >= x:",
			"\t\t\t\treturn a[bisect_left(a, x)]",
			"\t",
			"\tdef __getitem__(self, i: int) -> T:",
			"\t\t# Return the i-th element.",
			"\t\tif i < 0:",
			"\t\t\tfor a in reversed(self.a):",
			"\t\t\t\ti += len(a)",
			"\t\t\t\tif i >= 0: return a[i]",
			"\t\telse:",
			"\t\t\tfor a in self.a:",
			"\t\t\t\tif i < len(a): return a[i]",
			"\t\t\t\ti -= len(a)",
			"\t\traise IndexError",
			"\t",
			"\tdef pop(self, i: int = -1) -> T:",
			"\t\t# Pop and return the i-th element.",
			"\t\tif i < 0:",
			"\t\t\tfor b, a in enumerate(reversed(self.a)):",
			"\t\t\t\ti += len(a)",
			"\t\t\t\tif i >= 0: return self._pop(a, ~b, i)",
			"\t\telse:",
			"\t\t\tfor b, a in enumerate(self.a):",
			"\t\t\t\tif i < len(a): return self._pop(a, b, i)",
			"\t\t\t\ti -= len(a)",
			"\t\traise IndexError",
			"\t",
			"\tdef index(self, x: T) -> int:",
			"\t\t# Count the number of elements < x.",
			"\t\tans = 0",
			"\t\tfor a in self.a:",
			"\t\t\tif a[-1] >= x:",
			"\t\t\t\treturn ans + bisect_left(a, x)",
			"\t\t\tans += len(a)",
			"\t\treturn ans",
			"",
			"\tdef index_right(self, x: T) -> int:",
			"\t\t# Count the number of elements <= x.",
			"\t\tans = 0",
			"\t\tfor a in self.a:",
			"\t\t\tif a[-1] > x:",
			"\t\t\t\treturn ans + bisect_right(a, x)",
			"\t\t\tans += len(a)",
			"\t\treturn ans",
		]
	},
	"SortedMultiset": {
		"prefix": "SortedMultiSet",
		"body": [
			"import math",
			"",
			"class SortedMultiset(Generic[T]):",
			"\t#",
			"\t# https://github.com/tatyam-prime/SortedSet/blob/main/SortedSet.py",
			"\t#",
			"\tBUCKET_RATIO = 16",
			"\tSPLIT_RATIO = 24",
			"",
			"\tdef __init__(self, a: Iterable[T] = []) -> None:",
			"\t\t# Make a new SortedMultiset from iterable. / O(N) if sorted / O(N log N)",
			"\t\ta = list(a)",
			"\t\tn = self.size = len(a)",
			"\t\tif any(a[i] > a[i + 1] for i in range(n - 1)):",
			"\t\t\ta.sort()",
			"\t\tnum_bucket = int(math.ceil(math.sqrt(n / self.BUCKET_RATIO)))",
			"\t\tself.a = [a[n * i // num_bucket : n * (i + 1) // num_bucket] for i in range(num_bucket)]",
			"",
			"\tdef __iter__(self) -> Iterator[T]:",
			"\t\tfor i in self.a:",
			"\t\t\tfor j in i: yield j",
			"",
			"\tdef __reversed__(self) -> Iterator[T]:",
			"\t\tfor i in reversed(self.a):",
			"\t\t\tfor j in reversed(i): yield j",
			"",
			"\tdef __eq__(self, other) -> bool:",
			"\t\treturn list(self) == list(other)",
			"",
			"\tdef __len__(self) -> int:",
			"\t\treturn self.size",
			"",
			"\tdef __repr__(self) -> str:",
			"\t\treturn 'SortedMultiset' + str(self.a)",
			"",
			"\tdef __str__(self) -> str:",
			"\t\ts = str(list(self))",
			"\t\treturn '{' + s[1 : len(s) - 1] + '}'",
			"",
			"\tdef _position(self, x: T) -> Tuple[List[T], int, int]:",
			"\t\t# return the bucket, index of the bucket and position in which x should be. self must not be empty.",
			"\t\tfor i, a in enumerate(self.a):",
			"\t\t\tif x <= a[-1]: break",
			"\t\treturn (a, i, bisect_left(a, x))",
			"",
			"\tdef __contains__(self, x: T) -> bool:",
			"\t\tif self.size == 0: return False",
			"\t\ta, _, i = self._position(x)",
			"\t\treturn i != len(a) and a[i] == x",
			"",
			"\tdef count(self, x: T) -> int:",
			"\t\t# Count the number of x.",
			"\t\treturn self.index_right(x) - self.index(x)",
			"",
			"\tdef add(self, x: T) -> None:",
			"\t\t# Add an element. / O(√N)",
			"\t\tif self.size == 0:",
			"\t\t\tself.a = [[x]]",
			"\t\t\tself.size = 1",
			"\t\t\treturn",
			"\t\ta, b, i = self._position(x)",
			"\t\ta.insert(i, x)",
			"\t\tself.size += 1",
			"\t\tif len(a) > len(self.a) * self.SPLIT_RATIO:",
			"\t\t\tmid = len(a) >> 1",
			"\t\t\tself.a[b:b+1] = [a[:mid], a[mid:]]",
			"",
			"\tdef _pop(self, a: List[T], b: int, i: int) -> T:",
			"\t\tans = a.pop(i)",
			"\t\tself.size -= 1",
			"\t\tif not a: del self.a[b]",
			"\t\treturn ans",
			"",
			"\tdef discard(self, x: T) -> bool:",
			"\t\t# Remove an element and return True if removed. / O(√N)",
			"\t\tif self.size == 0: return False",
			"\t\ta, b, i = self._position(x)",
			"\t\tif i == len(a) or a[i] != x: return False",
			"\t\tself._pop(a, b, i)",
			"\t\treturn True",
			"",
			"\tdef lt(self, x: T) -> Optional[T]:",
			"\t\t# Find the largest element < x, or None if it doesn't exist.",
			"\t\tfor a in reversed(self.a):",
			"\t\t\tif a[0] < x:",
			"\t\t\t\treturn a[bisect_left(a, x) - 1]",
			"",
			"\tdef le(self, x: T) -> Optional[T]:",
			"\t\t#Find the largest element <= x, or None if it doesn't exist.",
			"\t\tfor a in reversed(self.a):",
			"\t\t\tif a[0] <= x:",
			"\t\t\t\treturn a[bisect_right(a, x) - 1]",
			"",
			"\tdef gt(self, x: T) -> Optional[T]:",
			"\t\t# Find the smallest element > x, or None if it doesn't exist.",
			"\t\tfor a in self.a:",
			"\t\t\tif a[-1] > x:",
			"\t\t\t\treturn a[bisect_right(a, x)]",
			"",
			"\tdef ge(self, x: T) -> Optional[T]:",
			"\t\t# Find the smallest element >= x, or None if it doesn't exist.'",
			"\t\tfor a in self.a:",
			"\t\t\tif a[-1] >= x:",
			"\t\t\t\treturn a[bisect_left(a, x)]",
			"",
			"\tdef __getitem__(self, i: int) -> T:",
			"\t\t# Return the i-th element.'",
			"\t\tif i < 0:",
			"\t\t\tfor a in reversed(self.a):",
			"\t\t\t\ti += len(a)",
			"\t\t\t\tif i >= 0: return a[i]",
			"\t\telse:",
			"\t\t\tfor a in self.a:",
			"\t\t\t\tif i < len(a): return a[i]",
			"\t\t\t\ti -= len(a)",
			"\t\traise IndexError",
			"",
			"\tdef pop(self, i: int = -1) -> T:",
			"\t\t# Pop and return the i-th element.",
			"\t\tif i < 0:",
			"\t\t\tfor b, a in enumerate(reversed(self.a)):",
			"\t\t\t\ti += len(a)",
			"\t\t\t\tif i >= 0: return self._pop(a, ~b, i)",
			"\t\telse:",
			"\t\t\tfor b, a in enumerate(self.a):",
			"\t\t\t\tif i < len(a): return self._pop(a, b, i)",
			"\t\t\t\ti -= len(a)",
			"\t\traise IndexError",
			"",
			"\tdef index(self, x: T) -> int:",
			"\t\t# Count the number of elements < x.",
			"\t\tans = 0",
			"\t\tfor a in self.a:",
			"\t\t\tif a[-1] >= x:",
			"\t\t\t\treturn ans + bisect_left(a, x)",
			"\t\t\tans += len(a)",
			"\t\treturn ans",
			"",
			"\tdef index_right(self, x: T) -> int:",
			"\t\t# Count the number of elements <= x.",
			"\t\tans = 0",
			"\t\tfor a in self.a:",
			"\t\t\tif a[-1] > x:",
			"\t\t\t\treturn ans + bisect_right(a, x)",
			"\t\t\tans += len(a)",
			"\t\treturn ans",
		]
	},
	"SegmentTree":{
		"prefix": "SegmentTree",
		"body": ["class SegmentTree:",
					"\t\"\"\"",
					"\thttps://qiita.com/takayg1/items/b7b3f7d458915bcc7a4e",
					"\t\"\"\"",
					"\tdef __init__(self, iter: Iterator, func: Callable[..., int], ele: Any) -> None:",
						"\t\t\"\"\"",
						"\t\titer: Iterator(初期化対象)",
						"\t\tfunc: 評価関数",
						"\t\tele: 単位元(モノイドの単位元)",
						"\t\t\"\"\"",
						"\t\tN = len(iter)",
						"\t\tself.func = func",
						"\t\tself.ele = ele",
						"\t\tself.length = 1 << (N - 1).bit_length()",
						"\t\tself.tree = [ele] * 2*self.length",
						"",
						"\t\tfor i in range(N):",
							"\t\t\tself.tree[self.length + i] = iter[i]",
						"\t\tfor i in range(self.length-1, 0, -1):",
							"\t\t\tself.tree[i] = self.func([self.tree[2*i], self.tree[2*i + 1]])",
						"",
					"\tdef update(self, index: int, value: Any) -> None:",
						"\t\t\"\"\"",
						"\t\tindex: 更新対象",
						"\t\tvalue: 更新値",
						"\t\tindex(0-index)の値をvalueに更新する",
						"\t\t\"\"\"",
						"\t\tindex += self.length",
						"\t\tself.tree[index] = value",
						"\t\twhile index > 1:",
							"\t\t\tself.tree[index >> 1] = self.func([self.tree[index], self.tree[index ^ 1]])",
							"\t\t\tindex >>= 1",
						"",
					"\tdef add(self, index: int, value: Any) -> None:",
						"\t\t\"\"\"",
						"\t\tindex: 更新対象",
						"\t\tvalue: 更新値",
						"\t\tindex(0-index)の値にvalueを加算する",
						"\t\t\"\"\"",
						"\t\tindex += self.length",
						"\t\tself.tree[index] += value",
						"\t\twhile index > 1:",
							"\t\t\tself.tree[index >> 1] = self.func([self.tree[index], self.tree[index ^ 1]])",
							"\t\t\tindex >>= 1",
						"",
					"\tdef get(self, l, r):",
						"\t\t\"\"\"",
						"\t\t[l, r)の区間の値に関して",
						"\t\tself.funcで評価を行いO(logN)で返す",
						"\t\t\"\"\"",
						"\t\tres = self.ele",
						"",
						"\t\tl += self.length",
						"\t\tr += self.length",
						"\t\twhile l < r:",
							"\t\t\tif l & 1:",
								"\t\t\t\tres = self.func([res, self.tree[l]])",
								"\t\t\t\tl += 1",
							"\t\t\tif r & 1:",
								"\t\t\t\tres = self.func([res, self.tree[r - 1]])",
							"\t\t\tl >>= 1",
							"\t\t\tr >>= 1",
        				"\t\treturn res",
				]
	},
	"SegmentTree with Lazy Update":{
		"prefix": "SegmentTreeWithLazyUpdate",
		"body": [
			"class SegmentTreeWithLazyUpdate:",
				"\t\"\"\"",
				"\thttps://qiita.com/ether2420/items/7b67b2b35ad5f441d686",
				"\t\"\"\"",
				"\tdef __init__(self, iter: Iterable, func: Callable[..., int], ele: Any) -> None:",
					"\t\t\"\"\"",
					"\t\titer: Iterator(初期化対象)",
					"\t\tfunc: 評価関数",
					"\t\tele: 単位元(モノイドの単位元)",
					"\t\tイテレータを受け取って、セグ木を構築する",
					"\t\t\"\"\"",
					"\t\tN = len(iter)",
					"\t\tself.func = func",
					"\t\tself.ele = ele",
					"\t\tself.length = 1 << (N - 1).bit_length()",
					"\t\tself.tree = [ele] * (2 * self.length)",
					"\t\tself.lazy = [None] * (2 * self.length)",
					"\t\tfor i in range(N):",
						"\t\t\tself.tree[self.length + i] = iter[i]",
					"\t\tfor i in range(self.length - 1, 0, -1):",
						"\t\t\tself.tree[i] = self.func([self.tree[2 * i], self.tree[2 * i + 1]])",
			"",
				"\tdef gindex(self, l: int, r: int):",
					"\t\t\"\"\"",
					"\t\t末尾の0の数を数えることで、伝搬される区間を列挙する",
					"\t\t[l ,r) : 更新対象",
					"\t\t\"\"\"",
					"\t\tl += self.length",
					"\t\tr += self.length",
					"\t\tlm = l >> (l & -l).bit_length()",
					"\t\trm = r >> (r & -r).bit_length()",
			"",
					"\t\twhile r > l:",
						"\t\t\tif l <= lm:",
							"\t\t\t\tyield l",
						"\t\t\tif r <= rm:",
							"\t\t\t\tyield r",
						"\t\t\tr >>= 1",
						"\t\t\tl >>= 1",
					"\t\twhile l:",
						"\t\t\tyield l",
						"\t\t\tl >>= 1",
				"\t",
				"\tdef propagate(self, *ids):",
					"\t\t\"\"\"",
					"\t\t伝搬処理",
					"\t\t\"\"\"",
					"\t\tfor i in reversed(ids):",
						"\t\t\tv = self.lazy[i]",
						"\t\t\tif v is None:",
							"\t\t\t\tcontinue",
						"\t\t\tself.lazy[2 * i] = v",
						"\t\t\tself.lazy[2 * i + 1] = v",
						"\t\t\tself.tree[2 * i] = v",
						"\t\t\tself.tree[2 * i + 1] = v",
						"\t\t\tself.lazy[i] = None",
			"",
				"\tdef update(self,l,r,x):",
					"\t\t\"\"\"",
					"\t\t[l, r): 更新対象(0-index)",
					"\t\tvalue: 更新値",
					"\t\t[l ,r)の値をvalueに更新する",
					"\t\t\"\"\"",
					"\t\tids = self.gindex(l,r)",
					"\t\tself.propagate(*self.gindex(l,r))",
					"\t\tl += self.length",
					"\t\tr += self.length",
					"\t\twhile l<r:",
						"\t\t\tif l&1:",
							"\t\t\t\tself.lazy[l] = x",
							"\t\t\t\tself.tree[l] = x",
							"\t\t\t\tl += 1",
						"\t\t\tif r&1:",
							"\t\t\t\tself.lazy[r-1] = x",
							"\t\t\t\tself.tree[r-1] = x",
						"\t\t\tr >>= 1",
						"\t\t\tl >>= 1",
					"\t\tfor i in ids:",
						"\t\t\tself.tree[i] = self.func([self.tree[2*i], self.tree[2*i+1]])",
			"",
				"\tdef get(self, l, r):",
					"\t\t\"\"\"",
					"\t\t[l, r)の区間の値に関して",
					"\t\tself.funcで評価を行いO(logN)で返す",
					"\t\t\"\"\"",
					"\t\t*idx, = self.gindex(l, r)",
					"\t\tself.propagate(*idx)",
			"",
					"\t\tres = self.ele",
					"\t\tl += self.length",
					"\t\tr += self.length",
					"\t\twhile l < r:",
						"\t\t\tif l & 1:",
							"\t\t\t\tres = self.func([res, self.tree[l]])",
							"\t\t\t\tl += 1",
						"\t\t\tif r & 1:",
							"\t\t\t\tres = self.func([res, self.tree[r - 1]])",
						"\t\t\tl >>= 1",
						"\t\t\tr >>= 1",
					"\t\treturn res",
		]
	},
	"SegmentTree with Lazy Add":{
		"prefix": "SegmentTreeWithLazyAdd",
		"body":["class SegmentTreeWithLazyAdd:",
					"\tdef __init__(self, iter: Iterable, func: Callable[..., int], ele: Any) -> None:",
						"\t\t\"\"\"",
						"\t\titer: Iterator(初期化対象)",
						"\t\tfunc: 評価関数",
						"\t\tele: 単位元(モノイドの単位元)",
						"\t\tイテレータを受け取って、セグ木を構築する",
						"\t\t\"\"\"",
						"\t\tN = len(iter)",
						"\t\tself.func = func",
						"\t\tself.ele = ele",
						"\t\tself.length = 1 << (N - 1).bit_length()",
						"\t\tself.tree = [ele] * (2 * self.length)",
						"\t\tself.lazy = [None] * (2 * self.length)",
						"\t\tfor i in range(N):",
							"\t\t\tself.tree[self.length + i] = iter[i]",
						"\t\tfor i in range(self.length - 1, 0, -1):",
							"\t\t\tself.tree[i] = self.func([self.tree[2 * i], self.tree[2 * i + 1]])",
				"",
					"\tdef gindex(self, l: int, r: int):",
						"\t\t\"\"\"",
						"\t\t末尾の0の数を数えることで、伝搬される区間を列挙する",
						"\t\t[l, r) : 更新対象",
						"\t\t\"\"\"",
						"\t\tl += self.length",
						"\t\tr += self.length",
						"\t\tlm = l >> (l & -l).bit_length()",
						"\t\trm = r >> (r & -r).bit_length()",
				"",
						"\t\twhile r > l:",
							"\t\t\tif l <= lm:",
								"\t\t\t\tyield l",
							"\t\t\tif r <= rm:",
								"\t\t\t\tyield r",
							"\t\t\tr >>= 1",
							"\t\t\tl >>= 1",
						"\t\twhile l:",
							"\t\t\tyield l",
							"\t\t\tl >>= 1",
					"\t",
					"\tdef propagate(self, *ids):",
						"\t\t\"\"\"",
						"\t\t伝搬処理",
						"\t\t\"\"\"",
						"\t\tfor i in reversed(ids):",
							"\t\t\tv = self.lazy[i]",
							"\t\t\tif v is None:",
								"\t\t\t\tcontinue",
							"\t\t\tif self.lazy[2 * i] is None:",
								"\t\t\t\tself.lazy[2 * i] = 0",
							"\t\t\tself.lazy[2 * i] += v",
							"\t\t\tif self.lazy[2 * i + 1] is None:",
								"\t\t\t\tself.lazy[2 * i + 1] = 0",
							"\t\t\tself.lazy[2 * i + 1] += v",
							"\t\t\tself.tree[2 * i] += v",
							"\t\t\tself.tree[2 * i + 1] += v",
							"\t\t\tself.lazy[i] = None",
				"",
					"\tdef add(self, l: int, r: int, x: Any) -> None:",
						"\t\t\"\"\"",
						"\t\t[l, r): 更新対象(0-index)",
						"\t\tvalue: 更新値",
						"\t\t[l ,r)の値にvalueを加算する",
						"\t\t\"\"\"",
						"\t\tidx = self.gindex(l, r)",
						"\t\tl += self.length",
						"\t\tr += self.length",
						"\t\twhile l < r:",
							"\t\t\tif l & 1:",
								"\t\t\t\tif self.lazy[l] is None:",
									"\t\t\t\t\tself.lazy[l] = 0",
								"\t\t\t\tself.lazy[l] += x",
								"\t\t\t\tself.tree[l] += x",
								"\t\t\t\tl += 1",
							"\t\t\tif r & 1:",
								"\t\t\t\tif self.lazy[r - 1] is None:",
									"\t\t\t\t\tself.lazy[r - 1] = 0",
								"\t\t\t\tself.lazy[r - 1] += x",
								"\t\t\t\tself.tree[r - 1] += x",
							"\t\t\tr >>= 1",
							"\t\t\tl >>= 1",
						"\t\tfor i in idx:",
							"\t\t\tself.tree[i] = self.func([self.tree[2 * i], self.tree[2 * i + 1]])",
				"",
					"\tdef get(self, l: int, r: int):",
						"\t\t\"\"\"",
						"\t\t[l, r)の区間の値に関して",
						"\t\tself.funcで評価を行いO(logN)で返す",
						"\t\t\"\"\"",
						"\t\tself.propagate(*self.gindex(l, r))",
				"",
						"\t\tres = self.ele",
						"\t\tl += self.length",
						"\t\tr += self.length",
						"\t\twhile l < r:",
							"\t\t\tif l & 1:",
								"\t\t\t\tres = self.func([res, self.tree[l]])",
								"\t\t\t\tl += 1",
							"\t\t\tif r & 1:",
								"\t\t\t\tres = self.func([res, self.tree[r - 1]])",
							"\t\t\tl >>= 1",
							"\t\t\tr >>= 1",
						"\t\treturn res",
		]
	},

	//グラフ
	"強連結成分の列挙": {
		"prefix": "scc",
		"body": [
			"def scc(G: List[List[int]], H: List[List[int]], N: int):",
				"\tused = [False] * N",
				"\tI = []",
			"",
				"\tdef dfs1(G: List[List[int]], v: int, used: List[bool], I: List[int]):",
					"\t\tused[v] = True",
					"\t\tfor nextv in G[v]:",
						"\t\t\tif not used[nextv]:",
							"\t\t\t\tdfs1(G, nextv, used, I)",
					"\t\tI.append(v)",
			"",
				"\tfor i in range(N):",
					"\t\tif not used[i]:",
						"\t\t\tdfs1(G, i, used, I)",
			"",
				"\tdef dfs2(G: List[List[int]], v: int, used: List[bool], connected_nodes: List[int]):",
					"\t\tused[v] = True",
					"\t\tconnected_nodes.append(v)",
					"\t\tfor nextv in G[v]:",
						"\t\t\tif not used[nextv]:",
							"\t\t\t\tdfs2(G, nextv, used, connected_nodes)",
			"",
				"\tI.reverse()",
				"\tused = [False] * N",
				"\tres = []",
				"\tfor i in I:",
					"\t\tif used[i]:",
						"\t\t\tcontinue",
					"\t\tconnected_nodes = []",
					"\t\tdfs2(H, i, used, connected_nodes)",
					"\t\tres.append(connected_nodes)",
			"",
				"\treturn res",
		]
	},

	// 探索
	"ダイクストラ法": {
		"prefix": "dijkstra",
		"body": [
			"def dijkstra(G, N, s):",
				"\tdistances = [INF] * N",
				"\tdistances[s] = 0",
				"",
				"\ttarget_nodes = []",
				"\theappush(target_nodes, (0, s))",
				"",
				"\twhile target_nodes:",
					"\t\tcurrent_dist, current_node = heappop(target_nodes)",
					"",
					"\t\tif current_dist > distances[current_node]:",
						"\t\t\tcontinue",
					"",
					"\t\tfor next_node, weight in G[current_node]:",
						"\t\t\tdist = current_dist + weight",
						"\t\t\tif dist < distances[next_node]:",
							"\t\t\t\tdistances[next_node] = dist",
							"\t\t\t\theappush(target_nodes, (dist, next_node))",
				"",
			"\treturn distances",
		]
	},
	"幅優先探索": {
		"prefix": "bfs",
		"body": [
			"#BFS",
			"def bfs(G, N, s, g):",
				"\t# dist:vからの距離, queue:探索キュー",
				"\tdist = [-1 for _ in range(N+1)]",
				"\tqueue = deque()",
				"\tdist[s] = 0",
				"\tqueue.append(s)",
				"\twhile queue:",
					"\t\tv = queue.popleft()",
					"\t\tfor next_v in G[v]:",
						"\t\t\tif dist[next_v] != -1:",
							"\t\t\t\tcontinue",
						"\t\t\tdist[next_v] = dist[v] + 1",
						"\t\t\tqueue.append(next_v)",
				"\treturn dist[g]",
		]
	},
	"深さ優先探索": {
		"prefix": "dfs",
		"body": [
			"# DFS",
			"seen = set()",
			"def dfs(G, v):",
				"\t# 頂点vを探索済みにする",
				"\tseen.add(v)",
				"",
				"\t# 探索",
				"\tfor next_v in G[v]:",
					"\t\t# 探索済みならスルー",
					"\t\tif next_v in seen:",
						"\t\t\tcontinue",
					"\t\tdfs(G, next_v)",
				"\tseen.remove(v)"
		]
	},
	"二分探索": {
		"prefix": "binarysearch",
		"body": [
			"# binary search",
			"def binary_search(array, target):",
    			"\t# 最大と最小の設定",
    			"\tlow = 0",
    			"\thigh = len(array) - 1",
				"",
    			"\t# 探索開始",
    			"\t# lowとhighが一致するまで(一致した点が挿入する点)",
    			"\twhile low <= high:",
        		"\t# 中間点の設定",
        			"\t\tmid = (low + high) // 2",
        			"\t\tmid_value = array[mid]",
					"",
        			"\t\tif mid_value == target:",
            			"\t\t\treturn mid",
        			"\t\telif mid_value < target:",
            			"\t\t\tlow = mid + 1",
        			"\t\telse:",
            			"\t\t\thigh = mid - 1",
    			"\treturn -1",
		]
	},
	"左二分探索": {
		"prefix": "binary_search_left",
		"body": [
			"# binary search left",
			"def binary_search_left(array, target):",
    			"\tlow = 0",
    			"\thigh = len(array)-1",
    			"\twhile low < high:",
        			"\t\t# midの設定",
        			"\t\tmid = (high+low)//2",
        			"\t\t# もし中心の値より目標値が低いなら",
        			"\t\tif array[mid] >= target:",
            			"\t\t\t# targetは、[mid, high]",
            			"\t\t\thigh = mid",
        			"\t\t# もし中心の値より目標値が高いなら",
        			"\t\telse:",
            			"\t\t\t# targetは、[low, mid]",
            			"\t\t\tlow = mid+1",
    			"\treturn low",
		]
	},
	"右二分探索": {
		"prefix": "binary_search_right",
		"body": [
			"def binary_search_right(array, target):",
				"\tlow = 0",
				"\thigh = len(array)-1",
				"\twhile low < high:",
					"\t\t# midの設定",
					"\t\tmid = (high+low)//2",
					"\t\t# もし中心の値より目標値が低いなら",
					"\t\tif array[mid] > target:",
						"\t\t\t# targetは、[mid, high)",
						"\t\t\thigh = mid",
					"\t\t# もし中心の値より目標値が高いなら",
					"\t\telse:",
						"\t\t\t# targetは、[low, mid)",
						"\t\t\tlow = mid+1",
				"\treturn low",
		]
	},
	"bit全探索": {
		"prefix": "bitsearch",
		"body": [
			"#bit_search",
			"res = 0",
			"for bit in range(2**N):",
    			"\t#ここで判定用の変数を初期化する",
    			"\t#ex) total = 0",
    			"\tfor i in range(N):",
        			"\t\tif (bit >> i) & 1:",
            			"\t\t\t#ここで何か操作を入れる",
            			"\t\t\t#total += list[i]",
    			"\t#組み合わせに関して、要素を満たすか判定する",
    			"\t#ex) if total == target:",
    			"\t#       res += 1"
		]
	},
	// other
	"4方向grid移動": {
		"prefix": "grid_move4",
		"body": [
			"# 文字列の指定がないときはmove2dを消す",
			"move2d = {'U':0, 'D':1, 'L':2, 'R':3}",
			"d = [[-1, 0], [1, 0], [0, -1], [0, 1]]",
	]
	},
	"8方向grid移動": {
		"prefix": "grid_move8",
		"body": [
			"dxs = [-1, 0, 1, 1, 1, 0, -1, -1]",
			"dys = [0, 1, 1, 1, 0, -1, -1, -1]",
			"for i in range(8):",
				"\tdx, dy = dxs[i], dys[i]"
	]
	},
	"[MIN, MAX)の範囲内かを調べる": {
		"prefix": "is_out_of_range",
		"body": [
			"def is_out_of_range(x:int, y:int, Xmi:int, Xma:int, Ymi:int, Yma:int) -> bool:",
				"\tif Xmi <= x < Xma and Ymi <= y < Yma:",
					"\t\treturn False",
				"\telse:",
					"\t\treturn True",
			"$1"
		]
	},
}