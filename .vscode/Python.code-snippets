{
	"python_template": {
		"prefix": "calltemplate",
		"body": [
			"#library",
			"import sys, re",
			"from math import ceil, floor, sqrt, pi, gcd",
			"from collections import deque, Counter",
			"from bisect import bisect, bisect_left, bisect_right",
			"from functools import lru_cache",
			"from itertools import permutations, combinations",
			"",
			"sys.setrecursionlimit(10**6)",
			"INF = float('inf')",
			"",
			"#main",
			"def main():",
			"\t$1",
			"",
			"if __name__ == '__main__':",
			"\tmain()"
		],
	},

	"複数回の(A, B)を別々に保存": {
		"prefix": "inputAB",
		"body": [
			"A, B = [], []",
			"for _ in range(N):",
			"\ta, b = map(int, input().split(' '))",
			"\tA.append(a)",
			"\tB.append(b)",
			"$1"
		]
	},

	"１入力": {
		"prefix": "inputN",
		"body": [
			"N = int(input())",
			"$1"
		]
	},

	"２入力": {
		"prefix": "inputNM",
		"body": [
			"N, M = map(int, input().split(' '))",
			"$1"
		]
	},

	"複数回の１入力": {
		"prefix": "inputL",
		"body": [
			"L = [int(input()) for _ in range(N)]",
			"$1"
		]
	},

	"複数回のN入力": {
		"prefix": "inputQ",
		"body": [
			"Q = [list(map(int, input().split(' '))) for _ in range(N)]",
			"$1"
		]
	},

	"[A_1, A_2, A_3, ...]": {
		"prefix": "inputA",
		"body": [
			"A = list(map(int, input().split(' ')))",
			"$1"
		]
	},

	"['a', 't', 'c', ...]": {
		"prefix": "inputS",
		"body": [
			"S = list(input())",
			"$1"
		]
	},

	"simple_graph": {
		"prefix": "input_simpleG",
		"body": [
			"N, M = map(int, input().split(' '))",
			"G = [[] for _ in range(N)]",
			"for _ in range(M):",
				"\ta, b = map(int, input().split(' '))",
				"\tG[a].append(b)",
				"\t# 有向グラフは次の列を削除",
				"\tG[b].append(a)",
			"$1"
		]
	},

	"weighted_graph": {
		"prefix": "input_weightedG",
		"body": [
			"N, M = map(int, input().split(' '))",
			"G = {}",
			"for _ in range(M):",
				"\ts, g, weight = map(int, input().split(' '))",
				"\tif s not in G:",
					"\t\tG[s] = {}",
				"\tG[s][g] = weight",
				"\t# 有向グラフは下の列を削除",
				"\tif g not in G:",
					"\t\tG[g] = {}",
				"\tG[g][s] = weight",
			"$1"
		]
	},

	"三項演算子": {
		"prefix": "3if",
		"body": [
			"$1 if $2 else $3",
		]
	},

	"素因数の列挙": {
		"prefix": "prime_factorization",
		"body": [
			"#prime_factorization",
			"def prime_factorization(N) -> list:",
		    "\tres = []",
		    "\tfor p in range(2, N):",
    	    	"\t\tif p * p > N:",
        		    "\t\t\tbreak",
        		"\t\tif N % p != 0:",
            		"\t\t\tcontinue",
        		"\t\te = 0",
	        	"\t\twhile N % p == 0:",
            		"\t\t\te += 1",
            		"\t\t\tN //= p",
        		"\t\tres.append((p, e))",
    		"\tif N != 1:",
		        "\t\tres.append((N, 1))",
    		"\treturn res"
		],
	},

	"素因数の判定": {
		"prefix": "prime_test",
		"body": [
			"#prime_test",
			"def prime_test(N):",
		    "\tres = 'Yes'",
		    "\tfor p in range(2, N):",
    	    	"\t\tif p * p > N:",
        		    "\t\t\tbreak",
        		"\t\tif N % p != 0:",
            		"\t\t\tcontinue",
	        	"\t\tif N % p == 0:",
            		"\t\t\tres = 'No'",
            		"\t\t\tbreak",
    		"\treturn res"
		],
	},

	"bit全探索": {
		"prefix": "bitsearch",
		"body": [
			"#bit_search",
			"res = 0",
			"for bit in range(2**N):",
    			"\t#ここで判定用の変数を初期化する",
    			"\t#ex) total = 0",
    			"\tfor i in range(N):",
        			"\t\tif (bit >> i) & 1:",
            			"\t\t\t#ここで何か操作を入れる",
            			"\t\t\t#total += list[i]",
    			"\t#組み合わせに関して、要素を満たすか判定する",
    			"\t#ex) if total == target:",
    			"\t#       res += 1"
		]
	},

	"幅優先探索": {
		"prefix": "bfs",
		"body": [
			"#BFS",
			"def bfs(G, N, s, g):",
				"\t# dist:vからの距離, queue:探索キュー",
				"\tdist = [-1 for _ in range(N+1)]",
				"\tqueue = deque()",
				"\tdist[s] = 0",
				"\tqueue.append(s)",
				"\twhile queue:",
					"\t\tv = queue.popleft()",
					"\t\tfor next_v in G[v]:",
						"\t\t\tif dist[next_v] != -1:",
							"\t\t\t\tcontinue",
						"\t\t\tdist[next_v] = dist[v] + 1",
						"\t\t\tqueue.append(next_v)",
				"\treturn dist[g]",
		]
	},

	"深さ優先探索": {
		"prefix": "dfs",
		"body": [
			"# DFS",
			"seen = set()",
			"def dfs(G, v):",
				"\t# 頂点vを探索済みにする",
				"\tseen.add(v)",
				"",
				"\t# 探索",
				"\tfor next_v in G[v]:",
					"\t\t# 探索済みならスルー",
					"\t\tif next_v in G:",
						"\t\t\tcontinue",
					"\t\tdfs(G, next_v)",
		]
	},

	"二分探索": {
		"prefix": "binarysearch",
		"body": [
			"# binary search",
			"def binary_search(array, target):",
    			"\t# 最大と最小の設定",
    			"\tlow = 0",
    			"\thigh = len(array) - 1",
				"",
    			"\t# 探索開始",
    			"\t# lowとhighが一致するまで(一致した点が挿入する点)",
    			"\twhile low <= high:",
        		"\t# 中間点の設定",
        			"\t\tmid = (low + high) // 2",
        			"\t\tmid_value = array[mid]",
					"",
        			"\t\tif mid_value == target:",
            			"\t\t\treturn mid",
        			"\t\telif mid_value < target:",
            			"\t\t\tlow = mid + 1",
        			"\t\telse:",
            			"\t\t\thigh = mid - 1",
    			"\treturn -1",
		]
	},
}