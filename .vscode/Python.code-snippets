{
	"python_template": {
		"prefix": "calltemplate",
		"body": [
			"#library",
			"import sys, re",
			"from math import ceil, floor, sqrt, pi, gcd",
			"import heapq",
			"from collections import deque, Counter, defaultdict",
			"from bisect import bisect, bisect_left, bisect_right",
			"from functools import lru_cache, cmp_to_key",
			"from itertools import permutations, combinations",
			"",
			"# ライブラリはここに貼り付け",
			"",
			"sys.setrecursionlimit(10**6)",
			"INF = float('inf')",
			"",
			"#main",
			"def main():",
			"\t$1",
			"",
			"if __name__ == '__main__':",
			"\tmain()"
		],
	},

	"複数回の(A, B)を別々に保存": {
		"prefix": "inputAB",
		"body": [
			"A, B = [], []",
			"for _ in range(N):",
			"\ta, b = map(int, input().split(' '))",
			"\tA.append(a)",
			"\tB.append(b)",
			"$1"
		]
	},

	"１入力": {
		"prefix": "inputN",
		"body": [
			"N = int(input())",
			"$1"
		]
	},

	"２入力": {
		"prefix": "inputNM",
		"body": [
			"N, M = map(int, input().split(' '))",
			"$1"
		]
	},

	"複数回の１入力": {
		"prefix": "inputL",
		"body": [
			"L = [int(input()) for _ in range(N)]",
			"$1"
		]
	},

	"複数回のN入力": {
		"prefix": "inputQ",
		"body": [
			"Q = [list(map(int, input().split(' '))) for _ in range(N)]",
			"$1"
		]
	},

	"[A_1, A_2, A_3, ...]": {
		"prefix": "inputA",
		"body": [
			"A = list(map(int, input().split(' ')))",
			"$1"
		]
	},

	"['a', 't', 'c', ...]": {
		"prefix": "inputS",
		"body": [
			"S = list(input())",
			"$1"
		]
	},

	"simple_graph": {
		"prefix": "input_simpleG",
		"body": [
			"N, M = map(int, input().split(' '))",
			"G = [[] for _ in range(N)]",
			"for _ in range(M):",
				"\ta, b = map(int, input().split(' '))",
				"\tG[a].append(b)",
				"\t# 有向グラフは次の列を削除",
				"\tG[b].append(a)",
			"$1"
		]
	},

	"weighted_graph": {
		"prefix": "input_weightedG",
		"body": [
			"N, M = map(int, input().split(' '))",
			"G = {}",
			"for _ in range(M):",
				"\ts, g, weight = map(int, input().split(' '))",
				"\tif s not in G:",
					"\t\tG[s] = {}",
				"\tG[s][g] = weight",
				"\t# 有向グラフは下の列を削除",
				"\tif g not in G:",
					"\t\tG[g] = {}",
				"\tG[g][s] = weight",
			"$1"
		]
	},

	"三項演算子": {
		"prefix": "3if",
		"body": [
			"$1 if $2 else $3",
		]
	},

	"素因数の列挙": {
		"prefix": "prime_factorization",
		"body": [
			"#prime_factorization",
			"def prime_factorization(N) -> list:",
		    "\tres = []",
		    "\tfor p in range(2, N):",
    	    	"\t\tif p * p > N:",
        		    "\t\t\tbreak",
        		"\t\tif N % p != 0:",
            		"\t\t\tcontinue",
        		"\t\te = 0",
	        	"\t\twhile N % p == 0:",
            		"\t\t\te += 1",
            		"\t\t\tN //= p",
        		"\t\tres.append((p, e))",
    		"\tif N != 1:",
		        "\t\tres.append((N, 1))",
    		"\treturn res"
		],
	},

	"素因数の判定": {
		"prefix": "prime_test",
		"body": [
			"#prime_test",
			"def prime_test(N):",
		    "\tres = 'Yes'",
		    "\tfor p in range(2, N):",
    	    	"\t\tif p * p > N:",
        		    "\t\t\tbreak",
        		"\t\tif N % p != 0:",
            		"\t\t\tcontinue",
	        	"\t\tif N % p == 0:",
            		"\t\t\tres = 'No'",
            		"\t\t\tbreak",
    		"\treturn res"
		],
	},

	"bit全探索": {
		"prefix": "bitsearch",
		"body": [
			"#bit_search",
			"res = 0",
			"for bit in range(2**N):",
    			"\t#ここで判定用の変数を初期化する",
    			"\t#ex) total = 0",
    			"\tfor i in range(N):",
        			"\t\tif (bit >> i) & 1:",
            			"\t\t\t#ここで何か操作を入れる",
            			"\t\t\t#total += list[i]",
    			"\t#組み合わせに関して、要素を満たすか判定する",
    			"\t#ex) if total == target:",
    			"\t#       res += 1"
		]
	},

	"幅優先探索": {
		"prefix": "bfs",
		"body": [
			"#BFS",
			"def bfs(G, N, s, g):",
				"\t# dist:vからの距離, queue:探索キュー",
				"\tdist = [-1 for _ in range(N+1)]",
				"\tqueue = deque()",
				"\tdist[s] = 0",
				"\tqueue.append(s)",
				"\twhile queue:",
					"\t\tv = queue.popleft()",
					"\t\tfor next_v in G[v]:",
						"\t\t\tif dist[next_v] != -1:",
							"\t\t\t\tcontinue",
						"\t\t\tdist[next_v] = dist[v] + 1",
						"\t\t\tqueue.append(next_v)",
				"\treturn dist[g]",
		]
	},

	"深さ優先探索": {
		"prefix": "dfs",
		"body": [
			"# DFS",
			"seen = set()",
			"def dfs(G, v):",
				"\t# 頂点vを探索済みにする",
				"\tseen.add(v)",
				"",
				"\t# 探索",
				"\tfor next_v in G[v]:",
					"\t\t# 探索済みならスルー",
					"\t\tif next_v in seen:",
						"\t\t\tcontinue",
					"\t\tdfs(G, next_v)",
				"\tseen.remove(v)"
		]
	},

	"二分探索": {
		"prefix": "binarysearch",
		"body": [
			"# binary search",
			"def binary_search(array, target):",
    			"\t# 最大と最小の設定",
    			"\tlow = 0",
    			"\thigh = len(array) - 1",
				"",
    			"\t# 探索開始",
    			"\t# lowとhighが一致するまで(一致した点が挿入する点)",
    			"\twhile low <= high:",
        		"\t# 中間点の設定",
        			"\t\tmid = (low + high) // 2",
        			"\t\tmid_value = array[mid]",
					"",
        			"\t\tif mid_value == target:",
            			"\t\t\treturn mid",
        			"\t\telif mid_value < target:",
            			"\t\t\tlow = mid + 1",
        			"\t\telse:",
            			"\t\t\thigh = mid - 1",
    			"\treturn -1",
		]
	},

	"左二分探索": {
		"prefix": "binary_search_left",
		"body": [
			"# binary search left",
			"def binary_search_left(array, target):",
    			"\tlow = 0",
    			"\thigh = len(array)-1",
    			"\twhile low < high:",
        			"\t\t# midの設定",
        			"\t\tmid = (high+low)//2",
        			"\t\t# もし中心の値より目標値が低いなら",
        			"\t\tif array[mid] >= target:",
            			"\t\t\t# targetは、[mid, high]",
            			"\t\t\thigh = mid",
        			"\t\t# もし中心の値より目標値が高いなら",
        			"\t\telse:",
            			"\t\t\t# targetは、[low, mid]",
            			"\t\t\tlow = mid+1",
    			"\treturn low",
		]
	},

	"右二分探索": {
		"prefix": "binary_search_right",
		"body": [
			"def binary_search_right(array, target):",
				"\tlow = 0",
				"\thigh = len(array)-1",
				"\twhile low < high:",
					"\t\t# midの設定",
					"\t\tmid = (high+low)//2",
					"\t\t# もし中心の値より目標値が低いなら",
					"\t\tif array[mid] > target:",
						"\t\t\t# targetは、[mid, high)",
						"\t\t\thigh = mid",
					"\t\t# もし中心の値より目標値が高いなら",
					"\t\telse:",
						"\t\t\t# targetは、[low, mid)",
						"\t\t\tlow = mid+1",
				"\treturn low",
		]
	},

	"三次元累積和": {
		"prefix": "cumsum3d",
		"body": [
			"def cumsum3d(n:int, a:list):",
				"\ttmp = [[[0] * (n + 1) for _ in range(n + 1)] for _ in range(n + 1)]",
				"\tfor i in range(n):",
					"\t\tfor j in range(n):",
						"\t\t\tfor k in range(n):",
							"\t\t\t\ttmp[i + 1][j + 1][k + 1] = (",
								"\t\t\t\t\ttmp[i][j+1][k+1]",
								"\t\t\t\t\t+ tmp[i+1][j][k+1]",
								"\t\t\t\t\t+ tmp[i+1][j+1][k]",
								"\t\t\t\t\t- tmp[i][j][k+1]",
								"\t\t\t\t\t- tmp[i][j+1][k]",
								"\t\t\t\t\t- tmp[i+1][j][k]",
								"\t\t\t\t\t+ tmp[i][j][k]",
								"\t\t\t\t\t+ a[i][j][k]",
								"\t\t\t\t)",
				"\treturn tmp"
		]
	},

	"二次元累積和": {
		"prefix": "cumsum2d",
		"body": [
			"def cumsum2d(n:int, a:list):",
				"\ttmp = [[0] * (n+1) for _ in range(n+1)]",
				"\tfor i in range(n):",
					"\t\tfor j in range(n):",
						"\t\t\ttmp[i+1][j+1] = (",
							"\t\t\t\ttmp[i+1][j]",
							"\t\t\t\t+ tmp[i][j+1]",
							"\t\t\t\t- tmp[i][j]",
							"\t\t\t\t+ a[i][j]",
							"\t\t\t\t)",
				"\treturn tmp",
		]
	},

	"Union Find": {
		"prefix": "unionfind",
		"body": [
			"class UnionFind():",
				"\t###",
				"\t#",
				"\t# UnionFindの実装",
				"\t#",
				"\t###",
				"\tdef __init__(self, n):",
					"\t\tself.n = n",
					"\t\tself.parents = [-1] * n",
				"\t# 要素xが属するグループの根を返す",
				"\tdef find(self, x):",
					"\t\tif self.parents[x] < 0:",
						"\t\t\treturn x",
					"\t\telse:",
						"\t\t\tself.parents[x] = self.find(self.parents[x])",
						"\t\t\treturn self.parents[x]",
				"\t# 要素xが属するグループと要素yが属するグループを併合する",
				"\tdef union(self, x, y):",
					"\t\tx = self.find(x)",
					"\t\ty = self.find(y)",
					"\t\tif x == y:",
						"\t\t\treturn ",
					"\t\tif self.parents[x] > self.parents[y]:",
						"\t\t\tx, y = y, x",
					"\t\tself.parents[x] += self.parents[y]",
					"\t\tself.parents[y] = x",
				"\t# 要素xが属するグループのサイズを返す",
				"\tdef size(self, x):",
					"\t\treturn -self.parents[self.find(x)]",
				"\t# 要素xと要素yが同じグループに属するかを返す",
				"\tdef same(self, x, y):",
					"\t\treturn self.find(x) == self.find(y)",
				"\t# 要素xが属するグループに属する要素をリストで返す",
				"\tdef members(self, x):",
					"\t\troot = self.find(x)",
					"\t\treturn [i for i in range(self.n) if self.find(i) == root]",
				"\t# 根のリストを返す",
				"\tdef roots(self):",
					"\t\treturn [i for i, x in enumerate(self.parents) if x < 0]",
				"\t# グループの数を返す",
				"\tdef group_count(self):",
					"\t\treturn len(self.roots())",
				"\t# {根:[そのグループに含まれる要素のリスト], ...}のdefaultdictを返す",
				"\tdef all_group_members(self):",
					"\t\tgroup_members = defaultdict(list)",
					"\t\tfor member in range(self.n):",
						"\t\t\tgroup_members[self.find(member)].append(member)",
					"\t\treturn group_members",
				"\tdef __str__(self):",
					"\t\treturn '\\n'.join(f'{r}: {m}' for r, m in self.all_group_members().items())"
		]
	},

	"Sortedset": {
		"prefix": "SortedSet",
		"body": [
			"import math",
			"from typing import Generic, Iterable, Iterator, List, Tuple, TypeVar, Optional",
			"T = TypeVar('T')",
			"",
			"class SortedSet(Generic[T]):",
			"\tBUCKET_RATIO = 16",
			"\tSPLIT_RATIO = 24",
			"\t",
			"\tdef __init__(self, a: Iterable[T] = []) -> None:",
			"\t\t# Make a new SortedSet from iterable. / O(N) if sorted and unique / O(N log N)",
			"\t\ta = list(a)",
			"\t\tn = len(a)",
			"\t\tif any(a[i] > a[i + 1] for i in range(n - 1)):",
			"\t\t\ta.sort()",
			"\t\tif any(a[i] >= a[i + 1] for i in range(n - 1)):",
			"\t\t\ta, b = [], a",
			"\t\t\tfor x in b:",
			"\t\t\t\tif not a or a[-1] != x:",
			"\t\t\t\t\ta.append(x)",
			"\t\tn = self.size = len(a)",
			"\t\tnum_bucket = int(math.ceil(math.sqrt(n / self.BUCKET_RATIO)))",
			"\t\tself.a = [a[n * i // num_bucket : n * (i + 1) // num_bucket] for i in range(num_bucket)]",
			"",
			"\tdef __iter__(self) -> Iterator[T]:",
			"\t\tfor i in self.a:",
			"\t\t\tfor j in i: yield j",
			"",
			"\tdef __reversed__(self) -> Iterator[T]:",
			"\t\tfor i in reversed(self.a):",
			"\t\t\tfor j in reversed(i): yield j",
			"\t",
			"\tdef __eq__(self, other) -> bool:",
			"\t\treturn list(self) == list(other)",
			"\t",
			"\tdef __len__(self) -> int:",
			"\t\treturn self.size",
			"\t",
			"\tdef __repr__(self) -> str:",
			"\t\treturn 'SortedSet' + str(self.a)",
			"\t",
			"\tdef __str__(self) -> str:",
			"\t\ts = str(list(self))",
			"\t\treturn '{' + s[1 : len(s) - 1] + '}'",
			"",
			"\tdef _position(self, x: T) -> Tuple[List[T], int, int]:",
			"\t\t# return the bucket, index of the bucket and position in which x should be. self must not be empty.",
			"\t\tfor i, a in enumerate(self.a):",
			"\t\t\tif x <= a[-1]: break",
			"\t\treturn (a, i, bisect_left(a, x))",
			"",
			"\tdef __contains__(self, x: T) -> bool:",
			"\t\tif self.size == 0: return False",
			"\t\ta, _, i = self._position(x)",
			"\t\treturn i != len(a) and a[i] == x",
			"",
			"\tdef add(self, x: T) -> bool:",
			"\t\t# Add an element and return True if added. / O(√N)",
			"\t\tif self.size == 0:",
			"\t\t\tself.a = [[x]]",
			"\t\t\tself.size = 1",
			"\t\t\treturn True",
			"\t\ta, b, i = self._position(x)",
			"\t\tif i != len(a) and a[i] == x: return False",
			"\t\ta.insert(i, x)",
			"\t\tself.size += 1",
			"\t\tif len(a) > len(self.a) * self.SPLIT_RATIO:",
			"\t\t\tmid = len(a) >> 1",
			"\t\t\tself.a[b:b+1] = [a[:mid], a[mid:]]",
			"\t\treturn True",
			"\t",
			"\tdef _pop(self, a: List[T], b: int, i: int) -> T:",
			"\t\tans = a.pop(i)",
			"\t\tself.size -= 1",
			"\t\tif not a: del self.a[b]",
			"\t\treturn ans",
			"",
			"\tdef discard(self, x: T) -> bool:",
			"\t\t# Remove an element and return True if removed. / O(√N)",
			"\t\tif self.size == 0: return False",
			"\t\ta, b, i = self._position(x)",
			"\t\tif i == len(a) or a[i] != x: return False",
			"\t\tself._pop(a, b, i)",
			"\t\treturn True",
			"\t",
			"\tdef lt(self, x: T) -> Optional[T]:",
			"\t\t# Find the largest element < x, or None if it doesn't exist.",
			"\t\tfor a in reversed(self.a):",
			"\t\t\tif a[0] < x:",
			"\t\t\t\treturn a[bisect_left(a, x) - 1]",

			"\tdef le(self, x: T) -> Optional[T]:",
			"\t\t# Find the largest element <= x, or None if it doesn't exist.",
			"\t\tfor a in reversed(self.a):",
			"\t\t\tif a[0] <= x:",
			"\t\t\t\treturn a[bisect_right(a, x) - 1]",
			"",
			"\tdef gt(self, x: T) -> Optional[T]:",
			"\t\t# Find the smallest element > x, or None if it doesn't exist.",
			"\t\tfor a in self.a:",
			"\t\t\tif a[-1] > x:",
			"\t\t\t\treturn a[bisect_right(a, x)]",
			"",
			"\tdef ge(self, x: T) -> Optional[T]:",
			"\t\t# Find the smallest element >= x, or None if it doesn't exist.",
			"\t\tfor a in self.a:",
			"\t\t\tif a[-1] >= x:",
			"\t\t\t\treturn a[bisect_left(a, x)]",
			"\t",
			"\tdef __getitem__(self, i: int) -> T:",
			"\t\t# Return the i-th element.",
			"\t\tif i < 0:",
			"\t\t\tfor a in reversed(self.a):",
			"\t\t\t\ti += len(a)",
			"\t\t\t\tif i >= 0: return a[i]",
			"\t\telse:",
			"\t\t\tfor a in self.a:",
			"\t\t\t\tif i < len(a): return a[i]",
			"\t\t\t\ti -= len(a)",
			"\t\traise IndexError",
			"\t",
			"\tdef pop(self, i: int = -1) -> T:",
			"\t\t# Pop and return the i-th element.",
			"\t\tif i < 0:",
			"\t\t\tfor b, a in enumerate(reversed(self.a)):",
			"\t\t\t\ti += len(a)",
			"\t\t\t\tif i >= 0: return self._pop(a, ~b, i)",
			"\t\telse:",
			"\t\t\tfor b, a in enumerate(self.a):",
			"\t\t\t\tif i < len(a): return self._pop(a, b, i)",
			"\t\t\t\ti -= len(a)",
			"\t\traise IndexError",
			"\t",
			"\tdef index(self, x: T) -> int:",
			"\t\t# Count the number of elements < x.",
			"\t\tans = 0",
			"\t\tfor a in self.a:",
			"\t\t\tif a[-1] >= x:",
			"\t\t\t\treturn ans + bisect_left(a, x)",
			"\t\t\tans += len(a)",
			"\t\treturn ans",
			"",
			"\tdef index_right(self, x: T) -> int:",
			"\t\t# Count the number of elements <= x.",
			"\t\tans = 0",
			"\t\tfor a in self.a:",
			"\t\t\tif a[-1] > x:",
			"\t\t\t\treturn ans + bisect_right(a, x)",
			"\t\t\tans += len(a)",
			"\t\treturn ans",
		]
	},
}